<!DOCTYPE html>
<html lang="en">
<head>
<script>
  MathJax = { 
    tex: {
		    inlineMath: [['$','$'], ['\\(','\\)']]
	} }
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<meta name="generator" content="plasTeX" />
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Oracle Reductions</title>
<link rel="next" href="chap-proof_systems.html" title="Proof Systems" />
<link rel="prev" href="sect0001.html" title="Introduction" />
<link rel="up" href="index.html" title="Formally Verified SNARKs in Lean" />
<link rel="stylesheet" href="styles/theme-white.css" />
<link rel="stylesheet" href="styles/amsthm.css" />
<link rel="stylesheet" href="styles/pygments.css" />
<link rel="stylesheet" href="styles/showmore.css" />
<link rel="stylesheet" href="styles/blueprint.css" />
<link rel="stylesheet" href="styles/extra_styles.css" />
</head>

<body>
<header>
<svg  id="toc-toggle" class="icon icon-list-numbered "><use xlink:href="symbol-defs.svg#icon-list-numbered"></use></svg>
<h1 id="doc_title"><a href="index.html">Formally Verified SNARKs in Lean</a></h1>
</header>

<div class="wrapper">
<nav class="toc">
<ul class="sub-toc-0">
<li class="">
  <a href="sect0001.html"><span class="toc_ref">1</span> <span class="toc_entry">Introduction</span></a>
 </li>
<li class=" active current">
  <a href="chap-oracle_reductions.html"><span class="toc_ref">2</span> <span class="toc_entry">Oracle Reductions</span></a>
  <span class="expand-toc">▼</span>
  <ul class="sub-toc-1 active">
     <li class="">
  <a href="chap-oracle_reductions.html#a0000000004"><span class="toc_ref">2.1</span> <span class="toc_entry">Definitions</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-2">
     <li class="">
  <a href="chap-oracle_reductions.html#a0000000005"><span class="toc_ref">2.1.1</span> <span class="toc_entry">Format</span></a>
 </li>
<li class="">
  <a href="chap-oracle_reductions.html#a0000000006"><span class="toc_ref">2.1.2</span> <span class="toc_entry">Security properties</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="chap-oracle_reductions.html#a0000000007"><span class="toc_ref">2.2</span> <span class="toc_entry">A Program Logic for Oracle Reductions</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-2">
     <li class="">
  <a href="chap-oracle_reductions.html#a0000000008"><span class="toc_ref">2.2.1</span> <span class="toc_entry">Changing Relations and Oracles</span></a>
 </li>
<li class="">
  <a href="chap-oracle_reductions.html#a0000000009"><span class="toc_ref">2.2.2</span> <span class="toc_entry">Sequential Composition</span></a>
 </li>
<li class="">
  <a href="chap-oracle_reductions.html#a0000000010"><span class="toc_ref">2.2.3</span> <span class="toc_entry">Virtualization</span></a>
 </li>
<li class="">
  <a href="chap-oracle_reductions.html#a0000000011"><span class="toc_ref">2.2.4</span> <span class="toc_entry">Substitution</span></a>
 </li>

  </ul>
 </li>

  </ul>
 </li>
<li class="">
  <a href="chap-proof_systems.html"><span class="toc_ref">3</span> <span class="toc_entry">Proof Systems</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-1">
     <li class="">
  <a href="chap-proof_systems.html#a0000000012"><span class="toc_ref">3.1</span> <span class="toc_entry">Simple Oracle Reductions</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-2">
     <li class="">
  <a href="chap-proof_systems.html#a0000000013"><span class="toc_ref">3.1.1</span> <span class="toc_entry">Polynomial Equality Testing</span></a>
 </li>
<li class="">
  <a href="chap-proof_systems.html#a0000000014"><span class="toc_ref">3.1.2</span> <span class="toc_entry">Batching Polynomial Evaluation Claims</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="chap-proof_systems.html#sec:sumcheck"><span class="toc_ref">3.2</span> <span class="toc_entry">The Sum-Check Protocol</span></a>
 </li>
<li class="">
  <a href="chap-proof_systems.html#a0000000015"><span class="toc_ref">3.3</span> <span class="toc_entry">The Spartan Protocol</span></a>
 </li>
<li class="">
  <a href="chap-proof_systems.html#a0000000016"><span class="toc_ref">3.4</span> <span class="toc_entry">The Ligero Polynomial Commitment Scheme</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="chap-commitment_schemes.html"><span class="toc_ref">4</span> <span class="toc_entry">Commitment Schemes</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-1">
     <li class="">
  <a href="chap-commitment_schemes.html#a0000000017"><span class="toc_ref">4.1</span> <span class="toc_entry">Definitions</span></a>
 </li>
<li class="">
  <a href="chap-commitment_schemes.html#sec:merkle_trees"><span class="toc_ref">4.2</span> <span class="toc_entry">Merkle Trees</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="chap-supporting_theories.html"><span class="toc_ref">5</span> <span class="toc_entry">Supporting Theories</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-1">
     <li class="">
  <a href="chap-supporting_theories.html#sec:polynomials"><span class="toc_ref">5.1</span> <span class="toc_entry">Polynomials</span></a>
 </li>
<li class="">
  <a href="chap-supporting_theories.html#sec:coding_theory"><span class="toc_ref">5.2</span> <span class="toc_entry">Coding Theory</span></a>
 </li>
<li class="">
  <a href="chap-supporting_theories.html#sec:vcvio"><span class="toc_ref">5.3</span> <span class="toc_entry">The VCVio Library</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="chap-references.html"><span class="toc_ref">6</span> <span class="toc_entry">References</span></a>
 </li>
<li class="">
  <a href="sect0002.html"><span class="toc_ref">7</span> <span class="toc_entry">Bibliography</span></a>
 </li>
<li ><a href="dep_graph_document.html">Dependency graph</a></li>
</ul>
</nav>

<div class="content">
<div class="content-wrapper">


<div class="main-text">
<h1 id="chap:oracle_reductions">2 Oracle Reductions</h1>

<h1 id="a0000000004">2.1 Definitions</h1>
<p>In this section, we give the basic definitions of a public-coin interactive oracle reduction (henceforth called an oracle reduction or IOR). In particular, we will define its building blocks, and various security properties. </p>
<h2 id="a0000000005">2.1.1 Format</h2>
<p>An <b class="bfseries">(interactive) oracle reduction</b> is an interactive protocol between two parties, a <em>prover</em> \(\mathcal{P}\) and a <em>verifier</em> \(\mathcal{V}\). It takes place in the following setting: </p>
<ol class="enumerate">
  <li><p>We work in an ambient dependent type theory (in our case, Lean). </p>
</li>
  <li><p>The protocol flow is fixed and defined by a given <em>type signature</em>, which describes in each round which party sends a message to the other, and the type of that message. </p>
</li>
  <li><p>The prover and verifier has access to some inputs (called the <em>context</em>) at the beginning of the protocol. These inputs are classified as follows: </p>
<ul class="itemize">
  <li><p><em>Public inputs</em>: available to both parties; </p>
</li>
  <li><p><em>Private inputs</em> (or <em>witness</em>): available only to the prover; </p>
</li>
  <li><p><em>Oracle inputs</em>: the underlying data is available to the prover, but it’s only exposed as an oracle to the verifier. An oracle interface for such inputs consists of a query type, a response type, and a function that takes in the underlying input, a query, and outputs a response. </p>
</li>
  <li><p><em>Shared oracle</em>: the oracle is available to both parties via an interface; in most cases, it is either empty, a probabilistic sampling oracle, or a random oracle. See&#160;<a href="chap-supporting_theories.html#sec:vcvio">Section 5.3</a> for more information on oracle computations. </p>
</li>
</ul>
</li>
  <li><p>The messages sent from the prover may either: 1) be seen directly by the verifier, or 2) only available to a verifier through an <em>oracle interface</em> (which specifies the type for the query and response, and the oracle’s behavior given the underlying message). </p>
</li>
  <li><p>All messages from \(\mathcal{V}\) are chosen uniformly at random from the finite type corresponding to that round. This property is called <em>public-coin</em> in the literature. </p>
</li>
</ol>
<p>We now go into more details on these objects. </p>
<div class="definition_thmwrapper theorem-style-definition" id="def:oracle_reduction_type_signature">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">1</span>
    <span class="definition_thmtitle">Type Signature of an Oracle Reduction</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:oracle_reduction_type_signature">#</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/ProtocolSpec" class="lean_decl">ProtocolSpec</a></li>
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/OracleInterface" class="lean_decl">OracleInterface</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  <p>  A protocol specification \(\rho : \mathsf{PSpec}\;  n\) of an oracle reduction is parametrized by a fixed number of messages sent in total. For each step of interaction, it specifies a direction for the messsage (prover to verifier, or vice versa), and a type for the message. If a message from the prover to the verifier is further marked as oracle, then we also expect an oracle interface for that message. In Lean, we handle these oracle interfaces via the \(\mathsf{OracleInterface}\) type class.  </p>

  </div>
</div>
<div class="definition_thmwrapper theorem-style-definition" id="def:context">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">2</span>
    <span class="definition_thmtitle">Context</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:context">#</a>
    
    
    
        </div>
  </div>
  <div class="definition_thmcontent">
  <p> In an oracle reduction, its <em>context</em> (denoted \(\Gamma \)) consists of a list of public inputs, a list of witness inputs, a list of oracle inputs, and a shared oracle (possibly represented as a list of lazily sampled query-response pairs). These inputs have the expected visibility. </p>
<p>For simplicity, we imagine the context as <em>append-only</em>, as we add new messages from the protocol execution. </p>

  </div>
</div>
<p>We define some supporting definitions for a protocol specification. </p>
<div class="definition_thmwrapper theorem-style-definition" id="def:transcript_and_related_defs">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">3</span>
    <span class="definition_thmtitle">Transcript &amp; Related Definitions</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:transcript_and_related_defs">#</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/ProtocolSpec.Transcript" class="lean_decl">ProtocolSpec.Transcript</a></li>
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/ProtocolSpec.Message" class="lean_decl">ProtocolSpec.Message</a></li>
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/ProtocolSpec.Challenge" class="lean_decl">ProtocolSpec.Challenge</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  <p>  Given protocol specification \(\rho : \mathsf{PSpec}\;  n\), its <em>transcript</em> up to round \(i\) is an element of type \(\rho _{[:i]} ::= \prod _{j {\lt} i} \rho \;  j\). We define the type of all challenges sent by the verifier as \(\rho .\mathsf{Chals} ::= \prod _{i \text{ s.t. } (\rho \;  i).\mathsf{fst} = \mathsf{V2P}} (\rho \;  i).\mathsf{snd}\).  </p>

  </div>
</div>
<div class="remark_thmwrapper theorem-style-definition" id="a0000000018">
  <div class="remark_thmheading">
    <span class="remark_thmcaption">
    Remark
    </span>
    <span class="remark_thmlabel">4</span>
    <span class="remark_thmtitle">Design Decision</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#a0000000018">#</a>
    
    
    
        </div>
  </div>
  <div class="remark_thmcontent">
  <p> We do not enforce a particular interaction flow in the definition of an interactive (oracle) reduction. This is done so that we can capture all protocols in the most generality. Also, we want to allow the prover to send multiple messages in a row, since each message may have a different oracle representation (for instance, in the Plonk protocol, the prover’s first message is a 3-tuple of polynomial commitments.) </p>

  </div>
</div>
<div class="definition_thmwrapper theorem-style-definition" id="def:prover_type_signature">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">5</span>
    <span class="definition_thmtitle">Type Signature of a Prover</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:prover_type_signature">#</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/Prover" class="lean_decl">Prover</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  <p>  A prover \(\mathcal{P}\) in an oracle reduction, given a context, is a stateful oracle computation that at each step of the protocol, either takes in a new message from the verifier, or sends a new message to the verifier.  </p>

  </div>
</div>
<p>Our modeling of oracle reductions only consider <em>public-coin</em> verifiers; that is, verifiers who only outputs uniformly random challenges drawn from the (finite) types, and uses no other randomness. Because of this fixed functionality, we can bake the verifier’s behavior in the interaction phase directly into the protocol execution semantics. </p>
<p>After the interaction phase, the verifier may then run some verification procedure to check the validity of the prover’s responses. In this procedure, the verifier gets access to the public part of the context, and oracle access to either the shared oracle, or the oracle inputs. </p>
<div class="definition_thmwrapper theorem-style-definition" id="def:verifier_type_signature">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">6</span>
    <span class="definition_thmtitle">Type Signature of a Verifier</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:verifier_type_signature">#</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/Verifier" class="lean_decl">Verifier</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  <p>  A verifier \(\mathcal{V}\) in an oracle reduction is an oracle computation that may perform a series of checks (i.e. ‘Bool‘-valued, or ‘Option Unit‘) on the given context.  </p>

  </div>
</div>
<p>An oracle reduction then consists of a type signature for the interaction, and a pair of prover and verifier for that type signature. </p>
<p>l </p>
<div class="definition_thmwrapper theorem-style-definition" id="def:interactive_oracle_reduction">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">7</span>
    <span class="definition_thmtitle">Interactive Oracle Reduction</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:interactive_oracle_reduction">#</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/OracleReduction" class="lean_decl">OracleReduction</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  <p>   An interactive oracle reduction for a given context \(\Gamma \) is a combination a prover and a verifier of the types specified above. </p>

  </div>
</div>
<p><b class="bfseries">PL Formalization.</b> We write our definitions in PL notation in&#160;<a href="chap-oracle_reductions.html#fig:type-defs">Figure 2.1</a>. The set of types \(\mathsf{Type}\) is the same as Lean’s dependent type theory (omitting universe levels); in particular, we care about basic dependent types (Pi and Sigma), finite natural numbers, finite fields, lists, vectors, and polynomials. </p>
<figure id="fig:type-defs">
  <div class="displaymath" id="a0000000019">
  \[ \begin{array}{rcl} \mathsf{Type} & ::=&  \mathsf{Unit} \mid \mathsf{Bool} \mid \mathbb {N} \mid \mathsf{Fin}\;  n \mid \mathbb {F}_q \mid \mathsf{List}\; (\alpha : \mathsf{Type}) \mid (i : \iota ) \to \alpha \;  i \mid (i : \iota ) \times \alpha \;  i \mid \dots \\[1em] \mathsf{Dir} & ::=&  \mathsf{P2V.Pub} \mid \mathsf{P2V.Orac} \mid \mathsf{V2P} \\ \mathsf{OI}\;  (\mathrm{M} : \mathsf{Type}) & ::=&  \langle \mathrm{Q}, \mathrm{R}, \mathrm{M} \to \mathrm{Q} \to \mathrm{R} \rangle \\ \mathsf{PSpec}\;  (n : \mathbb {N}) & ::=&  \mathsf{Fin}\;  n \to (d : \mathsf{Dir}) \times (M : \mathsf{Type}) \times (\mathsf{if}\;  d = \mathsf{P2V.Orac} \;  \mathsf{then} \;  \mathsf{OI}(M) \;  \mathsf{else} \;  \mathsf{Unit}) \\ \mathsf{OSpec} \;  (\iota : \mathsf{Type}) & ::=&  (i : \iota ) \to \mathsf{dom}\;  i \times \mathsf{range}\;  i \\[1em] \varSigma & ::=&  \emptyset \mid \varSigma \times \mathsf{Type}\\ \Omega & ::=&  \emptyset \mid \Omega \times \langle \mathrm{M} : \mathsf{Type}, \mathsf{OI}(\mathrm{M}) \rangle \\ \Psi & ::=&  \emptyset \mid \Psi \times \mathsf{Type}\\ \end{array} \]
</div>
<div class="displaymath" id="a0000000020">
  \[ \begin{array}{rcl} \Gamma & ::=&  (\Psi ; \Omega ; \varSigma ; \rho ; \mathcal{O})\\ \mathsf{OComp}^{\mathcal{O}}\;  (\alpha : \mathsf{Type}) & ::=&  \mid \;  \mathsf{pure}\;  (a : \alpha ) \\ & &  \mid \;  \mathsf{queryBind}\; (i : \iota )\;  (q : \mathsf{dom}\;  i)\;  (k : \mathsf{range}\;  i \to \mathsf{OComp}^{\mathcal{O}}\;  \alpha ) \\ & &  \mid \;  \mathsf{fail} \\[1em] \tau _{\mathsf{P}}(\Gamma ) & ::=&  (i : \mathsf{Fin}\;  n) \to (h : (\rho \;  i).\mathsf{fst} = \mathsf{P2V}) \to \\ & &  \varSigma \to \Omega \to \Psi \to \rho _{[:i]} \to \mathsf{OComp}^{\mathcal{O}}\; \left( (\rho \;  i).\mathsf{snd}\right) \\[1em]\tau _{\mathsf{V}}(\Gamma ) & ::=&  \varSigma \to (\rho .\mathsf{Chals}) \to \mathsf{OComp}^{\mathcal{O} :: \mathsf{OI}(\Omega ) :: \mathsf{OI}(\rho .\mathsf{Msg.Orac})}\;  \mathsf{Unit} \\[1em] \tau _{\mathsf{E}}(\Gamma ) & ::=&  \varSigma \to \Omega \to \rho .\mathsf{Transcript} \to \mathcal{O}.\mathsf{QueryLog} \to \Psi \end{array} \]
</div>
<figcaption>
  <span class="caption_title">Figure</span> 
  <span class="caption_ref">2.1</span> 
  <span class="caption_text">Type definitions for interactive oracle reductions</span> 
</figcaption>


</figure>
<p>Using programming language notation, we can express an interactive oracle reduction as a typing judgment: </p>
<div class="displaymath" id="a0000000021">
  \[  \Gamma := (\Psi ; \Theta ; \varSigma ; \rho ; \mathcal{O}) \vdash \mathcal{P} : \tau _{\mathsf{P}}(\Gamma ), \;  \mathcal{V} : \tau _{\mathsf{V}}(\Gamma )  \]
</div>
<p> where: </p>
<ul class="itemize">
  <li><p>\(\Psi \) represents the witness (private) inputs </p>
</li>
  <li><p>\(\Theta \) represents the oracle inputs </p>
</li>
  <li><p>\(\varSigma \) represents the public inputs (i.e. statements) </p>
</li>
  <li><p>\(\mathcal{O} : \mathsf{OSpec}\;  \iota \) represents the shared oracle </p>
</li>
  <li><p>\(\rho : \mathsf{PSpec}\;  n\) represents the protocol type signature </p>
</li>
  <li><p>\(\mathcal{P}\) and \(\mathcal{V}\) are the prover and verifier, respectively, being of the given types \(\tau _{\mathsf{P}}(\Gamma )\) and \(\tau _{\mathsf{V}}(\Gamma )\). </p>
</li>
</ul>
<p>To exhibit valid elements for the prover and verifier types, we will use existing functions in the ambient programming language (e.g. Lean). </p>
<p>We now define what it means to execute an oracle reduction. This is essentially achieved by first executing the prover, interspersed with oracle queries to get the verifier’s challenges (these will be given uniform random probability semantics later on), and then executing the verifier’s checks. Any message exchanged in the protocol will be added to the context. We may also log information about the execution, such as the log of oracle queries for the shared oracles, for analysis purposes (i.e. feeding information into the extractor). </p>
<div class="definition_thmwrapper theorem-style-definition" id="def:oracle_reduction_execution">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">8</span>
    <span class="definition_thmtitle">Execution of an Oracle Reduction</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:oracle_reduction_execution">#</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/OracleReduction.run" class="lean_decl">OracleReduction.run</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  

  </div>
</div>
<div class="remark_thmwrapper theorem-style-definition" id="a0000000022">
  <div class="remark_thmheading">
    <span class="remark_thmcaption">
    Remark
    </span>
    <span class="remark_thmlabel">9</span>
    <span class="remark_thmtitle">More efficient representation of oracle reductions</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#a0000000022">#</a>
    
    
    
        </div>
  </div>
  <div class="remark_thmcontent">
  <p> The presentation of oracle reductions as protocols on an append-only context is useful for reasoning, but it does not lead to the most efficient implementation for the prover and verifier. In particular, the prover cannot keep intermediate state, and thus needs to recompute everything from scratch for each new message. </p>
<p>To fix this mismatch, we will also define a stateful variant of the prover, and define a notion of observational equivalence between the stateless and stateful reductions. </p>

  </div>
</div>
<h2 id="a0000000006">2.1.2 Security properties</h2>
<p>We can now define properties of interactive reductions. The two main properties we consider in this project are completeness and various notions of soundness. We will cover zero-knowledge at a later stage. </p>
<p>First, for completeness, this is essentially probabilistic Hoare-style conditions on the execution of the oracle reduction (with the honest prover and verifier). In other words, given a predicate on the initial context, and a predicate on the final context, we require that if the initial predicate holds, then the final predicate holds with high probability (except for some <em>completeness</em> error). </p>
<div class="definition_thmwrapper theorem-style-definition" id="def:completeness">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">10</span>
    <span class="definition_thmtitle">Completeness</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:completeness">#</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/Reduction.completeness" class="lean_decl">Reduction.completeness</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  

  </div>
</div>
<p>Almost all oracle reductions we consider actually satisfy <em>perfect completeness</em>, which simplifies the proof obligation. In particular, this means we only need to show that no matter what challenges are chosen, the verifier will always accept given messages from the honest prover. </p>
<p>For soundness, we need to consider different notions. These notions differ in two main aspects: </p>
<ul class="itemize">
  <li><p>Whether we consider the plain soundness, or knowledge soundness. The latter relies on the notion of an <em>extractor</em>. </p>
</li>
  <li><p>Whether we consider plain, state-restoration, round-by-round, or rewinding notion of soundness. </p>
</li>
</ul>
<p>We note that state-restoration knowledge soundness is necessary for the security of the SNARK protocol obtained from the oracle reduction after composing with a commitment scheme and applying the Fiat-Shamir transform. It in turn is implied by either round-by-round knowledge soundness, or special soundness (via rewinding). At the moment, we only care about non-rewinding soundness, so mostly we will care about round-by-round knowledge soundness. </p>
<div class="definition_thmwrapper theorem-style-definition" id="def:soundness">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">11</span>
    <span class="definition_thmtitle">Soundness</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:soundness">#</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/Reduction.soundness" class="lean_decl">Reduction.soundness</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  

  </div>
</div>
<p>A (straightline) extractor for knowledge soundness is a deterministic algorithm that takes in the output public context after executing the oracle reduction, the side information (i.e. log of oracle queries from the malicious prover) observed during execution, and outputs the witness for the input context. </p>
<p>Note that since we assume the context is append-only, and we append only the public (or oracle) messages obtained during protocol execution, it follows that the witness stays the same throughout the execution. </p>
<div class="definition_thmwrapper theorem-style-definition" id="def:knowledge_soundness">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">12</span>
    <span class="definition_thmtitle">Knowledge Soundness</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:knowledge_soundness">#</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/Reduction.knowledgeSoundness" class="lean_decl">Reduction.knowledgeSoundness</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  

  </div>
</div>
<p>To define round-by-round (knowledge) soundness, we need to define the notion of a <em>state function</em>. This is a (possibly inefficient) function \(\mathsf{StateF}\) that, for every challenge sent by the verifier, takes in the transcript of the protocol so far and outputs whether the state is doomed or not. Roughly speaking, the requirement of round-by-round soundness is that, for any (possibly malicious) prover \(P\), if the state function outputs that the state is doomed on some partial transcript of the protocol, then the verifier will reject with high probability. </p>
<div class="definition_thmwrapper theorem-style-definition" id="def:state_function">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">13</span>
    <span class="definition_thmtitle">State Function</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:state_function">#</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/Reduction.StateFunction" class="lean_decl">Reduction.StateFunction</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  

  </div>
</div>
<div class="definition_thmwrapper theorem-style-definition" id="def:round_by_round_soundness">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">14</span>
    <span class="definition_thmtitle">Round-by-Round Soundness</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:round_by_round_soundness">#</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/Reduction.rbrSoundness" class="lean_decl">Reduction.rbrSoundness</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  

  </div>
</div>
<div class="definition_thmwrapper theorem-style-definition" id="def:round_by_round_knowledge_soundness">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">15</span>
    <span class="definition_thmtitle">Round-by-Round Knowledge Soundness</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:round_by_round_knowledge_soundness">#</a>
    
    
    
    <button class="modal lean">L∃∀N</button>
        <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
        
        <ul class="uses">
          
          <li><a href="https://verified-zkevm.github.io/ArkLib/docs/find/#doc/Reduction.rbrKnowledgeSoundness" class="lean_decl">Reduction.rbrKnowledgeSoundness</a></li>
          
        </ul>
    
      </div>
    </div>

    
        </div>
  </div>
  <div class="definition_thmcontent">
  

  </div>
</div>
<p>By default, the properties we consider are perfect completeness and (straightline) round-by-round knowledge soundness. We can encapsulate these properties into the following typing judgement: </p>
<div class="displaymath" id="a0000000023">
  \[  \Gamma := (\Psi ; \Theta ; \varSigma ; \rho ; \mathcal{O}) \vdash \{ \mathcal{R}_1\}  \quad \langle \mathcal{P}, \mathcal{V}, \mathcal{E}\rangle \quad \{ \! \! \{ \mathcal{R}_2; \mathsf{St}; \epsilon \} \! \! \}   \]
</div>
<h1 id="a0000000007">2.2 A Program Logic for Oracle Reductions</h1>
<p>In this section, we describe a program logic for reasoning about oracle reductions. In other words, we define a number of rules (or theorems) that govern how oracle reductions can be composed to form larger reductions, and how the resulting reduction inherits the security properties of the components. </p>
<p>The first group of rules changes relations and shared oracles. </p>
<h2 id="a0000000008">2.2.1 Changing Relations and Oracles</h2>
<p>Here we express the consequence rule. Namely, if we have an oracle reduction for \(\mathcal{R}_1 \implies \mathcal{R}_2\), along with \(\mathcal{R}_1' \implies \mathcal{R}_1\) and \(\mathcal{R}_2 \implies \mathcal{R}_2'\), then we obtain an oracle reduction for \(\mathcal{R}_1' \implies \mathcal{R}_2'\). </p>
<div class="displaymath" id="a0000000024">
  \[  \frac{\begin{array}{c} \Psi ; \Theta ; \Sigma \vdash \{ \mathcal{R}_1\} \;  \langle \mathcal{P},\,  \mathcal{V},\,  \mathcal{E}\rangle ^{\mathcal{O}} : \tau \; \{ \! \! \{ \mathcal{R}_2; \, \mathsf{St};\,  \epsilon \} \! \! \}  \\[1.5ex] \mathcal{R}_1’ \implies \mathcal{R}_1 \\[1.5ex] \mathcal{R}_2 \implies \mathcal{R}_2’ \end{array}}{\Psi ; \Theta ; \Sigma \vdash \{ \mathcal{R}_1'\} \;  \langle \mathcal{P},\,  \mathcal{V},\,  \mathcal{E}\rangle ^{\mathcal{O}} : \tau \; \{ \! \! \{ \mathcal{R}_2'; \, \mathsf{St};\,  \epsilon \} \! \! \}  } \quad \text{(Conseq)}  \]
</div>
<div class="displaymath" id="a0000000025">
  \[  \frac{\Psi ; \Theta ; \Sigma \vdash \{ \mathcal{R}_1\}  \;  \langle \mathcal{P}, \mathcal{V}, \mathcal{E}\rangle ^{\mathcal{O}} : \tau \;  \{ \! \! \{ \mathcal{R}_2; \mathsf{St}; \epsilon \} \! \! \}  }{\Psi ; \Theta ; \Sigma \vdash \{ \mathcal{R} \times \mathcal{R}_1\}  \;  \langle \mathcal{P}, \mathcal{V}, \mathcal{E}\rangle ^{\mathcal{O}} : \tau \;  \{ \! \! \{ \mathcal{R} \times \mathcal{R}_2; \mathsf{St}; \epsilon \} \! \! \}  } \quad \text{(Frame)}  \]
</div>
<div class="displaymath" id="a0000000026">
  \[  \frac{\begin{array}{c} \Psi ; \Theta ; \Sigma \vdash \{ \mathcal{R}_1\}  \;  \langle \mathcal{P}, \mathcal{V}, \mathcal{E}\rangle ^{\mathcal{O}_1} : \tau \;  \{ \! \! \{ \mathcal{R}_2; \mathsf{St}; \epsilon \} \! \! \}  \\[1.5ex] \mathcal{O}_1 \subset \mathcal{O}_2 \end{array}}{\Psi ; \Theta ; \Sigma \vdash \{ \mathcal{R}_1\}  \;  \langle \mathcal{P}, \mathcal{V}, \mathcal{E}\rangle ^{\mathcal{O}_2} : \tau \;  \{ \! \! \{ \mathcal{R}_2; \mathsf{St}; \epsilon \} \! \! \}  } \quad \text{(Oracle-Lift)}  \]
</div>
<p>TODO: figure out how the state function needs to change for these rules (they are basically the same, but not exactly) </p>
<h2 id="a0000000009">2.2.2 Sequential Composition</h2>
<p>The reason why we consider interactive (oracle) reductions at the core of our formalism is that we can <em>compose</em> these reductions to form larger reductions. Equivalently, we can take a complex <em>interactive (oracle) proof</em> (which differs only in that it reduces a relation to the <em>trivial</em> relation that always outputs true) and break it down into a series of smaller reductions. The advantage of this approach is that we can prove security properties (completeness and soundness) for each of the smaller reductions, and these properties will automatically transfer to the larger reductions. </p>
<p>This section is devoted to the composition of interactive (oracle) reductions, and proofs that the resulting reductions inherit the security properties of the two (or more) constituent reductions. </p>
<p>Sequential composition can be expressed as the folowing rule: </p>
<div class="displaymath" id="a0000000027">
  \[  \frac{\begin{array}{c} \Psi ; \Theta ; \varSigma \vdash \{ \mathcal{R}_1\}  \;  \langle \mathcal{P}_1, \mathcal{V}_1, \mathcal{E}_1\rangle ^{\mathcal{O}} : \tau _1 \;  \{ \! \! \{ \mathcal{R}_2; \mathsf{St}_1; \epsilon _1\} \! \! \}  \\[1.5ex] \Psi ; (\Theta :: \tau _1) ; \varSigma \vdash \{ \mathcal{R}_2\}  \;  \langle \mathcal{P}_2, \mathcal{V}_2, \mathcal{E}_2\rangle ^{\mathcal{O}} : \tau _2 \;  \{ \! \! \{ \mathcal{R}_3; \mathsf{St}_2; \epsilon _2\} \! \! \}  \end{array}}{\Psi ; (\Theta :: \tau _1 :: \tau _2) \  ; \varSigma \vdash \{ \mathcal{R}_1\}  \;  \langle \mathcal{P}_1 \circ \mathcal{P}_2, \mathcal{V}_1 \circ \mathcal{V}_2, \mathcal{E}_1 \circ _{\mathcal{V}_2} \mathcal{E}_2\rangle ^{\mathcal{O}} : \tau _1 \oplus \tau _2 \;  \{ \! \! \{ \mathcal{R}_3; \mathsf{St}_1 \oplus \mathsf{St}_2; \epsilon _1 \oplus \epsilon _2\} \! \! \}  } \quad \text{(Seq-Comp)}  \]
</div>
<h2 id="a0000000010">2.2.3 Virtualization</h2>
<p>Another tool we will repeatedly use is the ability to change the context of an oracle reduction. This is often needed when we want to adapt an oracle reduction in a simple context into one for a more complex context. </p>
<p>See the section on sum-check&#160;<a href="chap-proof_systems.html#sec:sumcheck">3.2</a> for an example. </p>
<div class="definition_thmwrapper theorem-style-definition" id="def:virtual_context_mapping">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">16</span>
    <span class="definition_thmtitle">Mapping into Virtual Context</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:virtual_context_mapping">#</a>
    
    
    
        </div>
  </div>
  <div class="definition_thmcontent">
  <p>  In order to apply an oracle reduction on virtual data, we will need to provide a mapping from the current context to the virtual context. This includes: </p>
<ul class="itemize">
  <li><p>A mapping from the current public inputs to the virtual public inputs. </p>
</li>
  <li><p>A simulation of the oracle inputs for the virtual context using the public and oracle inputs for the current context. </p>
</li>
  <li><p>A mapping from the current private inputs to the virtual private inputs. </p>
</li>
  <li><p>A simulation of the shared oracle for the virtual context using the shared oracle for the current context. </p>
</li>
</ul>

  </div>
</div>
<div class="definition_thmwrapper theorem-style-definition" id="def:virtual_oracle_reduction">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">17</span>
    <span class="definition_thmtitle">Virtual Oracle Reduction</span>
    <div class="thm_header_extras">

        </div>
    <div class="thm_header_hidden_extras">

    <a class="icon proof" href="chap-oracle_reductions.html#def:virtual_oracle_reduction">#</a>
    
    
    
        </div>
  </div>
  <div class="definition_thmcontent">
  <p>  Given a suitable mapping into a virtual context, we may define an oracle reduction via the following construction: </p>
<ul class="itemize">
  <li><p>The prover first applies the mappings to obtain the virtual context. The verifier does the same, but only for the non-private inputs. </p>
</li>
  <li><p>The prover and verifier then run the virtual oracle reduction on the virtual context. </p>
</li>
</ul>

  </div>
</div>
<p>We will show security properties for this virtualization process. One can see that completeness and soundness are inherited from the completeness and soundness of the virtual oracle reduction. However, (round-by-round) knowledge soundness is more tricky; this is because we must extract back to the witness of the original context from the virtual context. </p>
<div class="displaymath" id="a0000000028">
  \[  \frac{\begin{array}{c} \Psi ’; \Theta ’; \Sigma ’ \vdash \{ \mathcal{R}_1\}  \;  \langle \mathcal{P}, \mathcal{V}, \mathcal{E}\rangle ^{\mathcal{O}} : \tau \;  \{ \! \! \{ \mathcal{R}_2; \mathsf{St}; \epsilon \} \! \! \}  \\[1.5ex] f : (\Psi , \Theta , \Sigma ) \to (\Psi ’, \Theta ’, \Sigma ’) \\[1.5ex] g : \Psi ’ \to \Psi \\[1.5ex] f.\mathsf{fst} \circ g = \mathsf{id} \end{array}}{\Psi ; \Theta ; \Sigma \vdash \{ \mathcal{R}_1 \circ f\}  \;  \langle \mathcal{P} \circ f, \mathcal{V} \circ f, \mathcal{E} \circ (f, g)\rangle ^{\mathcal{O}} : \tau \;  \{ \! \! \{ \mathcal{R}_2 \circ f; \mathsf{St} \circ f; \epsilon \} \! \! \}  } \quad \text{(Virtual-Ctx)}  \]
</div>
<h2 id="a0000000011">2.2.4 Substitution</h2>
<p>Finally, we need a transformation / inference rule that allows us to change the message type in a given round of an oracle reduction. In other words, we substitute a value in the round with another value, followed by a reduction establishing the relationship between the new and old values. </p>
<p>Examples include: </p>
<ol class="enumerate">
  <li><p>Substituting an oracle input by a public input: </p>
<ul class="itemize">
  <li><p>Often by just revealing the underlying data. This has no change on the prover, and for the verifier, this means that any query to the oracle input can be locally computed. </p>
</li>
  <li><p>A variant of this is when the oracle input consists of a data along with a proof that the data satisfies some predicate. In this case, the verifier needs to additionally check that the predicate holds for the substituted data. </p>
</li>
  <li><p>Another common substitution is to replace a vector with its Merkle commitment, or a polynomial with its polynomial commitment. </p>
</li>
</ul>
</li>
  <li><p>Substituting an oracle input by another oracle input, followed by a reduction for each oracle query the verifier makes to the old oracle: </p>
<ul class="itemize">
  <li><p>This is also a variant of the previous case, where we do not fully substitute with a public input, but do a “half-substitution” by substituting with another oracle input. This happens e.g. when using a polynomial commitment scheme that is itself based on a vector commitment scheme. One can cast protocols like Ligero / Brakedown / FRI / STIR in this two-step process. </p>
</li>
</ul>
</li>
</ol>

</div> <!--main-text -->
</div> <!-- content-wrapper -->
</div> <!-- content -->
</div> <!-- wrapper -->

<nav class="prev_up_next">
  <svg  id="showmore-minus" class="icon icon-eye-minus showmore"><use xlink:href="symbol-defs.svg#icon-eye-minus"></use></svg>

  <svg  id="showmore-plus" class="icon icon-eye-plus showmore"><use xlink:href="symbol-defs.svg#icon-eye-plus"></use></svg>

  <a href="sect0001.html" title="Introduction"><svg  class="icon icon-arrow-left "><use xlink:href="symbol-defs.svg#icon-arrow-left"></use></svg>
</a>
  <a href="index.html" title="Formally Verified SNARKs in Lean"><svg  class="icon icon-arrow-up "><use xlink:href="symbol-defs.svg#icon-arrow-up"></use></svg>
</a>
  <a href="chap-proof_systems.html" title="Proof Systems"><svg  class="icon icon-arrow-right "><use xlink:href="symbol-defs.svg#icon-arrow-right"></use></svg>
</a>
</nav>

<script type="text/javascript" src="js/jquery.min.js"></script>
<script type="text/javascript" src="js/plastex.js"></script>
<script type="text/javascript" src="js/svgxuse.js"></script>
<script type="text/javascript" src="js/js.cookie.min.js"></script>
<script type="text/javascript" src="js/showmore.js"></script>
</body>
</html>